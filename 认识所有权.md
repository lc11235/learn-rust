所有权（系统）是Rust最为与众不同的特性，它让Rust无需垃圾回收（garbage collector）即可保障内存安全。因此，理解Rust中所有权如何工作是十分重要的。本章，我们将讲到所有权以及相关功能：借用、slice以及Rust如何在内存中布局数据。

## 什么是所有权

Rust的核心功能（之一）是**所有权**（ownership）。虽然该功能很容易解释，但它对语言的其他部分有着深刻地影响。

所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。

因为所有权对很多程序员来说都是一个新概念，需要一些时间来适应。好消息时随着你对Rust和所有权系统的规则越来越有经验，你就越能自然地编写出安全和高效的代码。持之以恒！

当你理解了所有权，你将有一个坚实的基础来理解那些使Rust独特的功能。在本章中，你将通过完成一些示例来学习所有权，这些示例基于一个常用的数据结构：字符串。

>
>
>### 栈（Stack）与堆（Heap）
>
>在很多语言中，你并不需要经常考虑栈与堆。不过在像Rust这样的系统编程语言中，值是位于栈上还是堆上在更大程度上影响了语言的行为以及为何必须做出这样的抉择。我们会在本章的稍后部分描述所有权与栈和堆相关的内容，所以这里只是一个用来预热的简要解释。
>
>栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。栈以放入值得顺序存储值并以相反顺序取出值。这也被称作**后进先出**（last in， first out）。想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆得顶部，当需要盘子时，也从顶部拿走。不能从中间也不能从底部增加或拿走盘子！增加数据叫做**进栈**（pulling onto the stack），而移出数据叫做**出栈**（popping off the stack）。
>
>栈中的所有数据都必须占用已知且固定的大小。在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆时缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆得某处找到一块足够大得空位。把它标记为已使用，并返回一个表示该地址的**指针**（pointer）。这个过程称作**在堆上分配内存**（allocating on the heap），有时简称为“分配”（allocating）。将数据推入栈中并不被认为时分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。
>
>想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。如果有人来迟了，他们也可以通过询问来找到你们坐在哪。
>
>入栈比在堆上分配内存要快，因为（入栈时）操作系统无需为存储新数据去搜索内存空间；其位置总是在栈顶。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。

